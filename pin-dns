#!/bin/bash
# pin-dns
#
# NAME
#     pin-dns - curl wrapper to override DNS resolution for a hostname (CDN bypass / origin pinning)
#
# SYNOPSIS
#     pin-dns HOSTNAME [TARGET] [PATH] [CURL_OPTS...]
#     pin-dns --host HOSTNAME [--target TARGET] [--path PATH] [--resolver DNS_SERVER_IP] [--scheme SCHEME] [--port PORT]
#               [--dry-run] [--no-silent] [--help] [--] [CURL_OPTS...]
#
# DESCRIPTION
#     pin-dns makes it easy to send a request to https://HOSTNAME/PATH while forcing curl to connect
#     to a chosen IP address (usually resolved from a CDN CNAME/edge hostname), without modifying
#     system DNS or /etc/hosts.
#
#     Under the hood it uses:
#         curl --resolve "HOSTNAME:PORT:IP" "SCHEME://HOSTNAME/PATH"
#
#     TARGET may be either:
#       - A hostname (e.g. commcloud.prod-xxxx-site-com.cc-ecdn.net) which pin-dns will resolve to an IP via dig; or
#       - An IP literal (IPv4 or IPv6), used directly.
#
#     If TARGET is omitted, pin-dns behaves like a convenience curl wrapper:
#         curl "https://HOSTNAME/PATH"
#
# POSITIONAL PARAMETERS
#     HOSTNAME
#         The hostname you want in the URL and Host/SNI (e.g. ecom-dev.somesite.com).
#
#     TARGET
#         Optional. Hostname or IP to map HOSTNAME to (for curl --resolve).
#         If a hostname is provided, pin-dns resolves it using dig and uses the last returned IP.
#
#     PATH
#         Optional. Path (and optional querystring). Examples:
#             /on/demandware.store/Sites-RefArch-Site
#             /some/path?q=stuff&q2=morestuff
#         If omitted, "/" is used.
#
# OPTIONS
#     --host HOSTNAME
#         Same as positional HOSTNAME. Useful for readability in scripts.
#
#     --target TARGET
#         Same as positional TARGET. Accepts either a hostname or an IP.
#
#     --path PATH
#         Same as positional PATH.
#
#     --resolver DNS_SERVER_IP
#         If provided, passes @DNS_SERVER_IP to dig to select a specific DNS server.
#
#     --scheme SCHEME
#         Default: https. Common values: https, http
#
#     --port PORT
#         Default: 443. This is the port used in curl --resolve "HOSTNAME:PORT:IP".
#
#     --dry-run
#         Do not execute curl. Print the resolved mapping and the curl command to stderr.
#
#     --no-silent
#         Do not add curl -sS by default.
#
#     -h, --help
#         Show this help text.
#
# NOTE
#     Only the options listed in this OPTIONS section are interpreted by pin-dns.
#     Any other -/-- flags you pass (for example -L, --header, --resolve) are
#     forwarded directly to curl unchanged.
#
# PASSING CURL OPTIONS
#     You may pass curl options in two ways:
#
#     1) After the positional parameters:
#            pin-dns HOST TARGET PATH -I -v
#
#     2) Explicitly separated with -- (useful if you prefer a clear separation,
#        or when you need to pass a non-option argument that begins with '-'):
#            pin-dns HOST TARGET PATH -- -H "X-Foo: bar" -I -v
#
#     In normal usage you do not need -- just to pass curl options; any -/-- flag
#     that is not one of pin-dns' own options is passed straight through to curl.
#
# USER-AGENT
#     pin-dns attempts to set a realistic Chrome User-Agent by reading Chrome's
#     Info.plist. If that fails, it falls back to "sfcc-test" and logs the
#     fallback to stderr. You can override this by passing your own
#     -A/--user-agent or -H "User-Agent: ..." to curl.
#
# ENVIRONMENT
#     PIN_DNS_CHROME_APP
#         Optional override for the Chrome app path used to determine version.
#         Default: /Applications/Google Chrome.app
#
# EXIT STATUS
#     0   Success
#     2   Usage / argument error
#     3   Dependency error (e.g. curl missing; dig missing when TARGET is a hostname)
#     4   Resolution error (dig returned no A/AAAA result)
#
_pin_dns() {
    local SCRIPT_PATH="${BASH_SOURCE[0]}"
    local SCRIPT_NAME; SCRIPT_NAME="$(basename "$SCRIPT_PATH")"

    _is_tty() { [ -t 2 ]; }

    _c_reset() { printf '\033[0m'; }
    _c_red() { printf '\033[31m'; }
    _c_yellow() { printf '\033[33m'; }
    _c_dim() { printf '\033[2m'; }
    _c_bold() { printf '\033[1m'; }

    _error() {
        if _is_tty; then
            _c_red; _c_bold
            printf '%s\n' "[ERR] $*"
            _c_reset
        else
            printf '%s\n' "[ERR] $*" >&2
        fi >&2
    }

    _warn() {
        if _is_tty; then
            _c_yellow; _c_bold
            printf '%s\n' "[WRN] $*"
            _c_reset
        else
            printf '%s\n' "[WRN] $*" >&2
        fi >&2
    }

    _info() {
        if _is_tty; then
            _c_dim
            printf '%s\n' "[INF] $*"
            _c_reset
        else
            printf '%s\n' "[INF] $*" >&2
        fi >&2
    }

    _print_help() {
        # Keep this closely aligned with the header comment
        cat >&2 <<'EOF'
NAME
    pin-dns - curl wrapper to override DNS resolution for a hostname (CDN bypass / origin pinning)

SYNOPSIS
    pin-dns HOSTNAME [TARGET] [PATH] [CURL_OPTS...]
    pin-dns --host HOSTNAME [--target TARGET] [--path PATH] [--resolver DNS_SERVER_IP] [--scheme SCHEME] [--port PORT]
              [--dry-run] [--no-silent] [--help] [--] [CURL_OPTS...]

DESCRIPTION
    pin-dns makes it easy to send a request to https://HOSTNAME/PATH while forcing curl to connect
    to a chosen IP address (usually resolved from a CDN CNAME/edge hostname), without modifying
    system DNS or /etc/hosts.

    Under the hood it uses:
        curl --resolve "HOSTNAME:PORT:IP" "SCHEME://HOSTNAME/PATH"

    TARGET may be either:
      - A hostname (e.g. commcloud.prod-xxxx-site-com.cc-ecdn.net) which pin-dns will resolve to an IP via dig; or
      - An IP literal (IPv4 or IPv6), used directly.

    If TARGET is omitted, pin-dns behaves like a convenience curl wrapper:
        curl "https://HOSTNAME/PATH"

POSITIONAL PARAMETERS
    HOSTNAME
        The hostname you want in the URL and Host/SNI (e.g. ecom-dev.somesite.com).

    TARGET
        Optional. Hostname or IP to map HOSTNAME to (for curl --resolve).
        If a hostname is provided, pin-dns resolves it using dig and uses the last returned IP.

    PATH
        Optional. Path (and optional querystring). Examples:
            /on/demandware.store/Sites-RefArch-Site
            /some/path?q=stuff&q2=morestuff
        If omitted, "/" is used.

OPTIONS
    --host HOSTNAME
        Same as positional HOSTNAME. Useful for readability in scripts.

    --target TARGET
        Same as positional TARGET. Accepts either a hostname or an IP.

    --path PATH
        Same as positional PATH.

    --resolver DNS_SERVER_IP
        If provided, passes @DNS_SERVER_IP to dig to select a specific DNS server.

    --scheme SCHEME
        Default: https. Common values: https, http

    --port PORT
        Default: 443. This is the port used in curl --resolve "HOSTNAME:PORT:IP".

    --dry-run
        Do not execute curl. Print the resolved mapping and the curl command to stderr.

    --no-silent
        Do not add curl -sS by default.

    -h, --help
        Show this help text.

NOTE
    Only the options listed in this OPTIONS section are interpreted by pin-dns.
    Any other -/-- flags you pass (for example -L, --header, --resolve) are
    forwarded directly to curl unchanged.

PASSING CURL OPTIONS
    You may pass curl options in two ways:

    1) After the positional parameters:
           pin-dns HOST TARGET PATH -I -v

    2) Explicitly separated with -- (useful if you prefer a clear separation,
       or when you need to pass a non-option argument that begins with '-'):
           pin-dns HOST TARGET PATH -- -H "X-Foo: bar" -I -v

    In normal usage you do not need -- just to pass curl options; any -/-- flag
    that is not one of pin-dns' own options is passed straight through to curl.

USER-AGENT
    pin-dns attempts to set a realistic Chrome User-Agent by reading Chrome's
    Info.plist. If that fails, it falls back to "sfcc-test" and logs the
    fallback to stderr. You can override this by passing your own
    -A/--user-agent or -H "User-Agent: ..." to curl.

ENVIRONMENT
    PIN_DNS_CHROME_APP
        Optional override for the Chrome app path used to determine version.
        Default: /Applications/Google Chrome.app

EXIT STATUS
    0   Success
    2   Usage / argument error
    3   Dependency error (e.g. curl missing; dig missing when TARGET is a hostname)
    4   Resolution error (dig returned no A/AAAA result)

EOF
    }

    _cmd_exists() { command -v "$1" >/dev/null 2>&1; }

    _is_ipv4() {
        local ip="$1"
        local a=""
        local b=""
        local c=""
        local d=""
        case "$ip" in
            *[!0-9.]*|'') return 1 ;;
        esac
        local IFS="."
        read -r a b c d <<EOF
$ip
EOF
        [ -n "$a" ] && [ -n "$b" ] && [ -n "$c" ] && [ -n "$d" ] || return 1
        [ "$a" -ge 0 ] 2>/dev/null && [ "$a" -le 255 ] || return 1
        [ "$b" -ge 0 ] 2>/dev/null && [ "$b" -le 255 ] || return 1
        [ "$c" -ge 0 ] 2>/dev/null && [ "$c" -le 255 ] || return 1
        [ "$d" -ge 0 ] 2>/dev/null && [ "$d" -le 255 ] || return 1
        return 0
    }

    _is_ipv6() {
        local ip="$1"
        case "$ip" in
            \[*\]) ip="${ip#[}"; ip="${ip%]}" ;;
        esac
        case "$ip" in
            *:*) ;;
            *) return 1 ;;
        esac
        case "$ip" in
            *[!0-9a-fA-F:]*|'') return 1 ;;
        esac
        return 0
    }

    _is_ip() {
        _is_ipv4 "$1" && return 0
        _is_ipv6 "$1" && return 0
        return 1
    }

    _get_user_agent() {
        local chrome_app_default="/Applications/Google Chrome.app"
        local chrome_app="${PIN_DNS_CHROME_APP:-$chrome_app_default}"
        if ! [ -d "$chrome_app" ]; then
            _error "Google Chrome not found at '$chrome_app'."
            return 1
        fi
        local info_plist="$chrome_app/Contents/Info.plist"
        local chrome_version; chrome_version="$(defaults read "$info_plist" CFBundleShortVersionString 2>/dev/null)"
        if [ -z "$chrome_version" ]; then
            _error "Unable to determine Chrome version (failed to read $info_plist)."
            return 1
        fi
        local ua_version="${chrome_version%%.*}.0.0.0"
        echo "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/$ua_version Safari/537.36"
    }

    _curl_args_has_user_agent() {
        local i=1
        while [ "$i" -le "$#" ]; do
            local a; a="$(eval "printf %s \"\${$i}\"")"
            case "$a" in
                -A|--user-agent)
                    return 0
                    ;;
                -A*)
                    return 0
                    ;;
                -H|--header)
                    local j=$((i + 1))
                    if [ "$j" -le "$#" ]; then
                        local h; h="$(eval "printf %s \"\${$j}\"")"
                        case "$h" in
                            [Uu]ser-[Aa]gent:*) return 0 ;;
                        esac
                    fi
                    ;;
                -H*)
                    case "$a" in
                        -H[Uu]ser-[Aa]gent:*) return 0 ;;
                    esac
                    ;;
            esac
            i=$((i + 1))
        done
        return 1
    }

    _resolve_target_to_ip() {
        local target="$1"
        local resolver="$2"

        if _is_ip "$target"; then
            printf '%s\n' "$target"
            return 0
        fi

        if ! _cmd_exists dig; then
            _error "dig is required to resolve TARGET hostnames, but was not found in PATH."
            return 3
        fi

        local dig_out=""
        if [ -n "$resolver" ]; then
            dig_out="$(dig @"$resolver" +short "$target" 2>/dev/null)"
        else
            dig_out="$(dig +short "$target" 2>/dev/null)"
        fi

        local ip; ip="$(printf '%s\n' "$dig_out" | tail -n 1)"
        if [ -z "$ip" ]; then
            _error "dig returned no results for TARGET '$target'."
            return 4
        fi

        printf '%s\n' "$ip"
        return 0
    }

    __unset() {
        unset -f _is_tty
        unset -f _c_reset
        unset -f _c_red
        unset -f _c_yellow
        unset -f _c_dim
        unset -f _c_bold
        unset -f _error
        unset -f _warn
        unset -f _info
        unset -f _print_help
        unset -f _cmd_exists
        unset -f _is_ipv4
        unset -f _is_ipv6
        unset -f _is_ip
        unset -f _get_user_agent
        unset -f _curl_args_has_user_agent
        unset -f _resolve_target_to_ip
        unset -f __unset
    }

    # Unset helper functions before returning, via trap
    # shellcheck disable=2329 # "This function is never invoked. Check usage (or ignored if invoked indirectly)."
    local __old_trap; __old_trap="$(trap -p RETURN)"
    trap '__unset || echo "'"$SCRIPT_NAME"' trap failed!" >&2; [ "$__old_trap" ] && eval "$__old_trap" || trap - RETURN' RETURN

    local host=""
    local target=""
    local path=""
    local resolver=""
    local scheme="https"
    local port="443"
    local dry_run=""
    local no_silent=""

    local -a curl_args=()

    if ! _cmd_exists curl; then
        _error "curl not found in PATH."
        return 3
    fi

    while [ "$#" -gt 0 ]; do
        local arg="$1"

        if [ "$arg" = "--" ]; then
            shift
            curl_args+=("$@")
            break
        fi

        case "$arg" in
            -h|--help)
                _print_help
                return 0
                ;;
            --host)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --host."; return 2; fi
                host="$1"
                shift
                continue
                ;;
            --target)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --target."; return 2; fi
                target="$1"
                shift
                continue
                ;;
            --path)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --path."; return 2; fi
                path="$1"
                shift
                continue
                ;;
            --resolver)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --resolver."; return 2; fi
                resolver="$1"
                shift
                continue
                ;;
            --scheme)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --scheme."; return 2; fi
                scheme="$1"
                shift
                continue
                ;;
            --port)
                shift
                if [ "$#" -lt 1 ]; then _error "Missing value for --port."; return 2; fi
                port="$1"
                shift
                continue
                ;;
            --dry-run)
                dry_run="1"
                shift
                continue
                ;;
            --no-silent)
                no_silent="1"
                shift
                continue
                ;;
            -*)
                # Unknown option: treat as the start of curl arguments
                curl_args+=("$@")
                break
                ;;
            *)
                if [ -z "$host" ]; then
                    host="$arg"
                    shift
                    continue
                fi
                if [ -z "$target" ]; then
                    target="$arg"
                    shift
                    continue
                fi
                if [ -z "$path" ]; then
                    path="$arg"
                    shift
                    continue
                fi
                curl_args+=("$@")
                break
                ;;
        esac
    done

    if [ -z "$host" ]; then
        _error "HOSTNAME is required."
        _print_help
        return 2
    fi

    if [ -z "$path" ]; then path="/"; fi

    case "$path" in
        /*) ;;
        \?*) path="/$path" ;;
        *) path="/$path" ;;
    esac

    local url="${scheme}://${host}${path}"

    local ip=""
    if [ -n "$target" ]; then
        local resolved; resolved="$(_resolve_target_to_ip "$target" "$resolver")"
        local rc=$?
        if [ "$rc" -ne 0 ]; then return "$rc"; fi
        ip="$resolved"
    fi

    local ua=""
    if _curl_args_has_user_agent "${curl_args[@]}"; then
        ua=""
    else
        local ua_out; ua_out="$(_get_user_agent)"
        local ua_rc=$?
        if [ "$ua_rc" -ne 0 ] || [ -z "$ua_out" ]; then
            _warn "User-Agent detection failed; falling back to 'sfcc-test'."
            ua="sfcc-test"
        else
            ua="$ua_out"
        fi
    fi

    local -a cmd=()

    cmd+=("curl")
    if [ -z "$no_silent" ]; then
        cmd+=("-sS")
    fi

    if [ -n "$ua" ]; then
        cmd+=("-A" "$ua")
    fi

    if [ -n "$ip" ]; then
        cmd+=("--resolve" "${host}:${port}:${ip}")
    fi

    cmd+=("${curl_args[@]}")

    local has_url=""
    local ca=""
    for ca in "${curl_args[@]}"; do
        case "$ca" in
            http://*|https://*)
                has_url="1"
                ;;
        esac
    done

    if [ -z "$has_url" ]; then
        cmd+=("$url")
    fi

    if [ -n "$ip" ]; then
        _info "Mapping ${host}:${port} -> ${ip} (from TARGET: ${target})"
    else
        _info "No TARGET provided; running curl against ${url}"
    fi

    if [ -n "$resolver" ]; then
        _info "dig resolver: ${resolver}"
    fi

    if [ -n "$dry_run" ]; then
        _info "Dry run: curl command follows"
        printf '%s' "[CMD] " >&2
        local x=""
        for x in "${cmd[@]}"; do
            case "$x" in
                *[[:space:]]*|*\"*|*\'*)
                    printf '%s ' "'$x'" >&2
                    ;;
                *)
                    printf '%s ' "$x" >&2
                    ;;
            esac
        done
        printf '\n' >&2
        return 0
    fi

    "${cmd[@]}"
    return $?
}
_pin_dns "$@"
unset -f _pin_dns
