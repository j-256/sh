#!/usr/bin/env bash
#! tested in: GNU bash, version 5.2.15(1)-release (x86_64-apple-darwin22.1.0) | older versions and other shells will work but not guaranteed
#shellcheck disable=SC2154 # "foo is referenced but not assigned."

#######################################################################################################
# Generate a .p12 client certificate for stg code upload MFA.                                         #
# Either run from the directory the cert bundle was unzipped to, or provide that path as an argument. #
#######################################################################################################

_generate_p12() {
    # Example hostname: "cert.staging.customer.realm.demandware.net"

    # Text colors for later use - by convention wrapped in {} when used below, for legibility
    local red;       red="$(tput setaf 9)"  # 9  == bright red (8+1)
    local green;   green="$(tput setaf 10)" # 10 == bright green (8+2)
    local yellow; yellow="$(tput setaf 11)" # 11 == bright yellow (8+3)
    local bold;     bold="$(tput bold)" # start bolding text
    local smul;     smul="$(tput smul)" # start underlining text
    local rmul;     rmul="$(tput rmul)" # stop underlining text
    local reset;   reset="$(tput sgr0)" # reset all formatting to terminal default
    # Note: There is no `tput unbold`. `tput bold` is $'\E[1m', which you would generally undo with
    #  $'\E[0m' or $'\E[m', but those essentially match `tput sgr0`, clearing all formatting

    _prompt() {
        local -r zsh="$ZSH_VERSION" # truthy if shell is zsh, falsy otherwise - in which case we assume bash
        local VARNAME="${1:?"variable name is required"}"
        local PROMPT="$2"
        local DEFAULT="$3"
        local PLACEHOLDER=""
        # if provided, set placeholder to the 4th parameter, substituting the special string "%DEFAULT%" with $DEFAULT 
        if [ -n "$4" ]; then
            PLACEHOLDER="${4//"%DEFAULT%"/"$DEFAULT"}"
        # ... otherwise, set placeholder to default value
        else
            PLACEHOLDER="$DEFAULT"
        fi

        # Display prompt in default color and placeholder in gray
        printf "%s\e[90m%s\e[0m" "$PROMPT" "$PLACEHOLDER"
        # Move the cursor back to the end of the prompt
        # `tput cub 0` still moves the cursor back one, so only run if necessary
        if [ ${#PLACEHOLDER} -ne 0 ]; then
            tput cub ${#PLACEHOLDER}
        fi

        # Read the first character to detect when the user starts typing
        local first_char
        if [ "$zsh" ]; then
            IFS= read -r -k1 first_char
        else
            IFS= read -r -N 1 first_char
        fi

        local input
        # If the input character is not empty or just a newline, read the entire line
        if [ -n "$first_char" ] && [ "$first_char" != $'\n' ]; then
            # Clear the rest of the line, read a line of input, and prepend the initial character
            tput el
            local line; IFS= read -r line
            input="$first_char$line"
        fi

        # Store the line input by the user, or the default value if none was provided, to the provided variable name
        eval "$VARNAME"'="${input:-"$DEFAULT"}"'
    }
    _file_exists() {
        [ -f "$1" ] || { echo "File not found: $1" >&2 && return 1; }
        return 0
    }
    _repeat() { # repeats a string n times
        printf "%$2s" | sed "s/ /$1/g"
    }
    _bold() {
        echo "$bold$*$reset"
    }

    # TODO: We should just include the path in the filenames rather than changing to the directory and back
    local wd="$1" # working directory
    # Save old dir to `cd` back to
    local old_dir="$PWD"
    # `cd` to working directory (or current if not provided, which will be a no-op)
    cd "${wd:-"$PWD"}" || { echo "Error: Failed to change to specified directory" >&2 && return 1; }

    local hostname
    printf %s "Hostname (cert.staging.***): "
    read -r hostname
    echo
    # Make sure we end up with a good hostname no matter what form it's provided in
    # Any PIG instance's BM hostname will end up in the "cert.staging" form, including providing as little as "production-customer-realm"
    hostname="$(printf %s "$hostname" | sed 's/_/./g; s/-/./g;
                                             s/^production//; s/^development//; s/^staging//; s/^cert\.staging//;
                                             s/^/cert.staging/;
                                             s/\.demandware\.net$//;
                                             s/$/.demandware.net/'
    )"

    # Assemble cert bundle filenames and check that they all exist before proceeding
    local ca_cert_filename="${hostname}_01.crt"
    local ca_key_filename="${hostname}_01.key"
    local ca_pass_filename="${hostname}_01.txt"
    local ca_serial_filename="${hostname}.srl" # CA serial is the only one which doesn't end in _01
    local any_missing
    _file_exists "$ca_cert_filename" || any_missing=true
    _file_exists "$ca_key_filename" || any_missing=true
    _file_exists "$ca_pass_filename" || any_missing=true
    _file_exists "$ca_serial_filename" || any_missing=true
    [ "$any_missing" ] && echo "Necessary file(s) missing, aborting p12 generation" >&2 && return 1

    # Define output file names
    local user="$USER"
    local req_filename="$user-$hostname.req"
    local key_filename="$user-$hostname.key"
    local pem_filename="$user-$hostname.pem"
    local p12_filename="$user-$hostname.p12"

    # Print the filenames which will be used
    cat <<EOF
${smul}Using these filenames:${rmul}
  $ca_cert_filename
  $ca_key_filename
  $ca_pass_filename
  $ca_serial_filename
  $req_filename
  $key_filename
  $pem_filename
  $p12_filename
EOF
    echo

    # local -r PLACEHOLDER="(<ENTER> for %DEFAULT%)"
    # Prompt for desired cert expiration, in years
    local -i years
    _prompt years "Years until expiration: " 10 #"$PLACEHOLDER"
    local -i days=$((years*365))
    echo

    if ! openssl req -new -sha256 -newkey rsa:2048 -nodes -out "$req_filename" -keyout "$key_filename"; then
        _bold "\`openssl req\` (step 1/3) failed - .req and .key files not generated" >&2 && return 1
    fi
    printf '%s\n' '' "$(_bold "Created CSR:")" "$req_filename"
    printf '%s\n' "$(_bold "Created private key:")" "$key_filename" ''

    # Back up existing clipboard contents
    local clipboard; clipboard="$(pbpaste)"
    # Copy password from text file to clipboard and print
    local pass; pass="$(cat "$ca_pass_filename")"
    if printf %s "$pass" | pbcopy; then
        # Print hyphens all the way across for a horizontal rule
        local term_width; term_width="$(tput cols)"
        echo "${red}$(_repeat '-' "$term_width")${reset}"
        echo "${red}${bold}Pass phrase for ${yellow}$ca_key_filename${red}: ${green}$pass${reset}"
        echo "${red}(already copied to clipboard, just use ${yellow}Cmd+V${red}/${yellow}Ctrl+V${red} to paste and hit Enter)${reset}"
        echo "${red}(no text will appear because it is a secure prompt)${reset}"
        echo "${red}$(_repeat '-' "$term_width")${reset}"
    fi

    if openssl x509 -req -in "$req_filename" -out "$pem_filename" -days "$days" -CA "$ca_cert_filename" -CAkey "$ca_key_filename" -CAserial "$ca_serial_filename"; then
        printf '%s\n' '' "$(_bold "Created X.509 intermediate certificate:")" "$pem_filename" ''
        # Restore clipboard if needed
        [ "$clipboard" ] && printf %s "$clipboard" | pbcopy
        # "OPTIONAL" line is printed right before the "Enter Export Password" prompt from the pkcs12 command
        echo "${smul}OPTIONAL${rmul} (press enter for blank password)"
        if openssl pkcs12 -export -in "$pem_filename" -inkey "$key_filename" -certfile "$ca_cert_filename" -name "$user-$hostname" -out "$p12_filename"; then
            printf '%s\n' '' "$(_bold "Created PKCS12 client certificate:")" "$p12_filename" ''
            _bold "Full path to p12:"
            realpath "$p12_filename"
        else
            _bold "\`openssl pkcs12\` (step 3/3) failed - .p12 file not generated" >&2 && return 1
        fi
    else
        # Restore clipboard if needed
        [ "$clipboard" ] && printf %s "$clipboard" | pbcopy
        _bold "\`openssl x509\` (step 2/3) failed - .pem file not generated" >&2 && return 1
    fi

    # Clean up internal functions to avoid polluting global namespace
    unset -f _prompt
    unset -f _file_exists
    unset -f _repeat
    unset -f _bold
    cd "$old_dir" || { echo "Error: Failed to revert to original directory" >&2 && return 1; }
}

_generate_p12 "$@"
